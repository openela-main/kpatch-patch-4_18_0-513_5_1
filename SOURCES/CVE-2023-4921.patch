From 800b6415522a85b64d32a5151769dc3bd6c15dde Mon Sep 17 00:00:00 2001
From: Joe Lawrence <joe.lawrence@redhat.com>
Date: Wed, 31 Jan 2024 14:42:29 -0500
Subject: [KPATCH CVE-2023-4921] kpatch fixes for CVE-2023-4921

Kernels:
4.18.0-513.5.1.el8_9
4.18.0-513.9.1.el8_9
4.18.0-513.11.1.el8_9


Kpatch-MR: https://gitlab.com/redhat/prdsc/rhel/src/kpatch/rhel-8/-/merge_requests/217
Changes since last build:
[x86_64]:
igb_main.o: changed function: igb_configure
sch_atm.o: changed function: atm_tc_peek
sch_atm.o: changed function: sch_atm_dequeue
sch_drr.o: changed function: drr_dequeue
sch_dsmark.o: changed function: dsmark_peek
sch_ets.o: changed function: ets_qdisc_dequeue
sch_hfsc.o: changed function: hfsc_change_class
sch_hfsc.o: changed function: hfsc_enqueue
sch_hfsc.o: changed function: qdisc_peek_len
sch_multiq.o: changed function: multiq_peek
sch_prio.o: changed function: prio_peek
sch_qfq.o: changed function: qfq_dequeue
sch_qfq.o: changed function: qfq_enqueue
sch_red.o: changed function: red_peek
sch_sfb.o: changed function: sfb_peek
sch_tbf.o: changed function: tbf_dequeue
tls_sw.o: changed function: tls_sw_do_sendpage

[ppc64le]:
sch_atm.o: changed function: atm_tc_bind_filter
sch_atm.o: changed function: atm_tc_delete
sch_atm.o: changed function: atm_tc_destroy
sch_atm.o: changed function: atm_tc_find
sch_atm.o: changed function: atm_tc_graft
sch_atm.o: changed function: atm_tc_leaf
sch_atm.o: changed function: atm_tc_peek
sch_atm.o: changed function: atm_tc_put
sch_atm.o: changed function: atm_tc_reset
sch_atm.o: changed function: atm_tc_tcf_block
sch_atm.o: changed function: sch_atm_dequeue
sch_drr.o: changed function: drr_dequeue
sch_dsmark.o: changed function: dsmark_bind_filter
sch_dsmark.o: changed function: dsmark_change
sch_dsmark.o: changed function: dsmark_destroy
sch_dsmark.o: changed function: dsmark_peek
sch_dsmark.o: changed function: dsmark_reset
sch_ets.o: changed function: ets_qdisc_dequeue
sch_hfsc.o: changed function: hfsc_change_class
sch_hfsc.o: changed function: hfsc_dequeue
sch_hfsc.o: changed function: hfsc_enqueue
sch_hfsc.o: new function: qdisc_peek_len
sch_multiq.o: changed function: multiq_peek
sch_prio.o: changed function: prio_peek
sch_qfq.o: changed function: qfq_dequeue
sch_qfq.o: changed function: qfq_enqueue
sch_red.o: changed function: red_peek
sch_sfb.o: changed function: sfb_peek
sch_tbf.o: changed function: tbf_dequeue
tls_sw.o: changed function: tls_sw_do_sendpage

---------------------------

Modifications:

- redirected to qdisc_peek_dequeued() by modifying functions that
  called '->peek(qdisc)' rather than by modifying plug_qdisc_ops
- don't remove existing WARN_ONCE instances to avoid kpatch-build
  "unreconcilable difference" error in .data.once section

commit 2235a2bcb7b172056c763b292bfe97ad83601163
Author: Davide Caratti <dcaratti@redhat.com>
Date:   Tue Oct 17 17:05:20 2023 +0200

    net: sched: sch_qfq: Fix UAF in qfq_dequeue()

    JIRA: https://issues.redhat.com/browse/RHEL-14423
    CVE: CVE-2023-4921
    Y-Commit: 7739a863095d1885ba926bdc0aa0e390b8862644

    O-JIRA: https://issues.redhat.com/browse/RHEL-14032
    Upstream Status: net.git commit 8fc134fee27f

    commit 8fc134fee27f2263988ae38920bc03da416b03d8
    Author: valis <sec@valis.email>
    Date:   Fri Sep 1 12:22:37 2023 -0400

        net: sched: sch_qfq: Fix UAF in qfq_dequeue()

        When the plug qdisc is used as a class of the qfq qdisc it could trigger a
        UAF. This issue can be reproduced with following commands:

          tc qdisc add dev lo root handle 1: qfq
          tc class add dev lo parent 1: classid 1:1 qfq weight 1 maxpkt 512
          tc qdisc add dev lo parent 1:1 handle 2: plug
          tc filter add dev lo parent 1: basic classid 1:1
          ping -c1 127.0.0.1

        and boom:

        [  285.353793] BUG: KASAN: slab-use-after-free in qfq_dequeue+0xa7/0x7f0
        [  285.354910] Read of size 4 at addr ffff8880bad312a8 by task ping/144
        [  285.355903]
        [  285.356165] CPU: 1 PID: 144 Comm: ping Not tainted 6.5.0-rc3+ #4
        [  285.357112] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-2 04/01/2014
        [  285.358376] Call Trace:
        [  285.358773]  <IRQ>
        [  285.359109]  dump_stack_lvl+0x44/0x60
        [  285.359708]  print_address_description.constprop.0+0x2c/0x3c0
        [  285.360611]  kasan_report+0x10c/0x120
        [  285.361195]  ? qfq_dequeue+0xa7/0x7f0
        [  285.361780]  qfq_dequeue+0xa7/0x7f0
        [  285.362342]  __qdisc_run+0xf1/0x970
        [  285.362903]  net_tx_action+0x28e/0x460
        [  285.363502]  __do_softirq+0x11b/0x3de
        [  285.364097]  do_softirq.part.0+0x72/0x90
        [  285.364721]  </IRQ>
        [  285.365072]  <TASK>
        [  285.365422]  __local_bh_enable_ip+0x77/0x90
        [  285.366079]  __dev_queue_xmit+0x95f/0x1550
        [  285.366732]  ? __pfx_csum_and_copy_from_iter+0x10/0x10
        [  285.367526]  ? __pfx___dev_queue_xmit+0x10/0x10
        [  285.368259]  ? __build_skb_around+0x129/0x190
        [  285.368960]  ? ip_generic_getfrag+0x12c/0x170
        [  285.369653]  ? __pfx_ip_generic_getfrag+0x10/0x10
        [  285.370390]  ? csum_partial+0x8/0x20
        [  285.370961]  ? raw_getfrag+0xe5/0x140
        [  285.371559]  ip_finish_output2+0x539/0xa40
        [  285.372222]  ? __pfx_ip_finish_output2+0x10/0x10
        [  285.372954]  ip_output+0x113/0x1e0
        [  285.373512]  ? __pfx_ip_output+0x10/0x10
        [  285.374130]  ? icmp_out_count+0x49/0x60
        [  285.374739]  ? __pfx_ip_finish_output+0x10/0x10
        [  285.375457]  ip_push_pending_frames+0xf3/0x100
        [  285.376173]  raw_sendmsg+0xef5/0x12d0
        [  285.376760]  ? do_syscall_64+0x40/0x90
        [  285.377359]  ? __static_call_text_end+0x136578/0x136578
        [  285.378173]  ? do_syscall_64+0x40/0x90
        [  285.378772]  ? kasan_enable_current+0x11/0x20
        [  285.379469]  ? __pfx_raw_sendmsg+0x10/0x10
        [  285.380137]  ? __sock_create+0x13e/0x270
        [  285.380673]  ? __sys_socket+0xf3/0x180
        [  285.381174]  ? __x64_sys_socket+0x3d/0x50
        [  285.381725]  ? entry_SYSCALL_64_after_hwframe+0x6e/0xd8
        [  285.382425]  ? __rcu_read_unlock+0x48/0x70
        [  285.382975]  ? ip4_datagram_release_cb+0xd8/0x380
        [  285.383608]  ? __pfx_ip4_datagram_release_cb+0x10/0x10
        [  285.384295]  ? preempt_count_sub+0x14/0xc0
        [  285.384844]  ? __list_del_entry_valid+0x76/0x140
        [  285.385467]  ? _raw_spin_lock_bh+0x87/0xe0
        [  285.386014]  ? __pfx__raw_spin_lock_bh+0x10/0x10
        [  285.386645]  ? release_sock+0xa0/0xd0
        [  285.387148]  ? preempt_count_sub+0x14/0xc0
        [  285.387712]  ? freeze_secondary_cpus+0x348/0x3c0
        [  285.388341]  ? aa_sk_perm+0x177/0x390
        [  285.388856]  ? __pfx_aa_sk_perm+0x10/0x10
        [  285.389441]  ? check_stack_object+0x22/0x70
        [  285.390032]  ? inet_send_prepare+0x2f/0x120
        [  285.390603]  ? __pfx_inet_sendmsg+0x10/0x10
        [  285.391172]  sock_sendmsg+0xcc/0xe0
        [  285.391667]  __sys_sendto+0x190/0x230
        [  285.392168]  ? __pfx___sys_sendto+0x10/0x10
        [  285.392727]  ? kvm_clock_get_cycles+0x14/0x30
        [  285.393328]  ? set_normalized_timespec64+0x57/0x70
        [  285.393980]  ? _raw_spin_unlock_irq+0x1b/0x40
        [  285.394578]  ? __x64_sys_clock_gettime+0x11c/0x160
        [  285.395225]  ? __pfx___x64_sys_clock_gettime+0x10/0x10
        [  285.395908]  ? _copy_to_user+0x3e/0x60
        [  285.396432]  ? exit_to_user_mode_prepare+0x1a/0x120
        [  285.397086]  ? syscall_exit_to_user_mode+0x22/0x50
        [  285.397734]  ? do_syscall_64+0x71/0x90
        [  285.398258]  __x64_sys_sendto+0x74/0x90
        [  285.398786]  do_syscall_64+0x64/0x90
        [  285.399273]  ? exit_to_user_mode_prepare+0x1a/0x120
        [  285.399949]  ? syscall_exit_to_user_mode+0x22/0x50
        [  285.400605]  ? do_syscall_64+0x71/0x90
        [  285.401124]  entry_SYSCALL_64_after_hwframe+0x6e/0xd8
        [  285.401807] RIP: 0033:0x495726
        [  285.402233] Code: ff ff ff f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b8 0f 1f 00 41 89 ca 64 8b 04 25 18 00 00 00 85 c0 75 11 b8 2c 00 00 00 0f 09
        [  285.404683] RSP: 002b:00007ffcc25fb618 EFLAGS: 00000246 ORIG_RAX: 000000000000002c
        [  285.405677] RAX: ffffffffffffffda RBX: 0000000000000040 RCX: 0000000000495726
        [  285.406628] RDX: 0000000000000040 RSI: 0000000002518750 RDI: 0000000000000000
        [  285.407565] RBP: 00000000005205ef R08: 00000000005f8838 R09: 000000000000001c
        [  285.408523] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000002517634
        [  285.409460] R13: 00007ffcc25fb6f0 R14: 0000000000000003 R15: 0000000000000000
        [  285.410403]  </TASK>
        [  285.410704]
        [  285.410929] Allocated by task 144:
        [  285.411402]  kasan_save_stack+0x1e/0x40
        [  285.411926]  kasan_set_track+0x21/0x30
        [  285.412442]  __kasan_slab_alloc+0x55/0x70
        [  285.412973]  kmem_cache_alloc_node+0x187/0x3d0
        [  285.413567]  __alloc_skb+0x1b4/0x230
        [  285.414060]  __ip_append_data+0x17f7/0x1b60
        [  285.414633]  ip_append_data+0x97/0xf0
        [  285.415144]  raw_sendmsg+0x5a8/0x12d0
        [  285.415640]  sock_sendmsg+0xcc/0xe0
        [  285.416117]  __sys_sendto+0x190/0x230
        [  285.416626]  __x64_sys_sendto+0x74/0x90
        [  285.417145]  do_syscall_64+0x64/0x90
        [  285.417624]  entry_SYSCALL_64_after_hwframe+0x6e/0xd8
        [  285.418306]
        [  285.418531] Freed by task 144:
        [  285.418960]  kasan_save_stack+0x1e/0x40
        [  285.419469]  kasan_set_track+0x21/0x30
        [  285.419988]  kasan_save_free_info+0x27/0x40
        [  285.420556]  ____kasan_slab_free+0x109/0x1a0
        [  285.421146]  kmem_cache_free+0x1c2/0x450
        [  285.421680]  __netif_receive_skb_core+0x2ce/0x1870
        [  285.422333]  __netif_receive_skb_one_core+0x97/0x140
        [  285.423003]  process_backlog+0x100/0x2f0
        [  285.423537]  __napi_poll+0x5c/0x2d0
        [  285.424023]  net_rx_action+0x2be/0x560
        [  285.424510]  __do_softirq+0x11b/0x3de
        [  285.425034]
        [  285.425254] The buggy address belongs to the object at ffff8880bad31280
        [  285.425254]  which belongs to the cache skbuff_head_cache of size 224
        [  285.426993] The buggy address is located 40 bytes inside of
        [  285.426993]  freed 224-byte region [ffff8880bad31280, ffff8880bad31360)
        [  285.428572]
        [  285.428798] The buggy address belongs to the physical page:
        [  285.429540] page:00000000f4b77674 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0xbad31
        [  285.430758] flags: 0x100000000000200(slab|node=0|zone=1)
        [  285.431447] page_type: 0xffffffff()
        [  285.431934] raw: 0100000000000200 ffff88810094a8c0 dead000000000122 0000000000000000
        [  285.432757] raw: 0000000000000000 00000000800c000c 00000001ffffffff 0000000000000000
        [  285.433562] page dumped because: kasan: bad access detected
        [  285.434144]
        [  285.434320] Memory state around the buggy address:
        [  285.434828]  ffff8880bad31180: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
        [  285.435580]  ffff8880bad31200: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
        [  285.436264] >ffff8880bad31280: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
        [  285.436777]                                   ^
        [  285.437106]  ffff8880bad31300: fb fb fb fb fb fb fb fb fb fb fb fb fc fc fc fc
        [  285.437616]  ffff8880bad31380: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
        [  285.438126] ==================================================================
        [  285.438662] Disabling lock debugging due to kernel taint

        Fix this by:
        1. Changing sch_plug's .peek handler to qdisc_peek_dequeued(), a
        function compatible with non-work-conserving qdiscs
        2. Checking the return value of qdisc_dequeue_peeked() in sch_qfq.

        Fixes: 462dbc9101ac ("pkt_sched: QFQ Plus: fair-queueing service at DRR cost")
        Reported-by: valis <sec@valis.email>
        Signed-off-by: valis <sec@valis.email>
        Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
        Link: https://lore.kernel.org/r/20230901162237.11525-1-jhs@mojatatu.com
        Signed-off-by: Paolo Abeni <pabeni@redhat.com>

    Signed-off-by: Davide Caratti <dcaratti@redhat.com>
    Signed-off-by: Patrick Talbert <ptalbert@redhat.com>

commit 4b5500be74401513b99c011ecff24d31e6c7857c
Author: Davide Caratti <dcaratti@redhat.com>
Date:   Thu Nov 9 16:29:59 2023 +0100

    net: sched: sch_qfq: Use non-work-conserving warning handler

    JIRA: https://issues.redhat.com/browse/RHEL-14423
    CVE: CVE-2023-4921
    Y-Commit: de172f3c62f10b97761754fd5de1399a6740b923

    O-JIRA: https://issues.redhat.com/browse/RHEL-14032
    Upstream Status: net.git commit 6d25d1dc76bf

    commit 6d25d1dc76bf5943a5c1f4bb74d66d5eac58eb77
    Author: Liu Jian <liujian56@huawei.com>
    Date:   Mon Oct 23 14:47:29 2023 +0800

        net: sched: sch_qfq: Use non-work-conserving warning handler

        A helper function for printing non-work-conserving alarms is added in
        commit b00355db3f88 ("pkt_sched: sch_hfsc: sch_htb: Add non-work-conserving
         warning handler."). In this commit, use qdisc_warn_nonwc() instead of
        WARN_ONCE() to handle the non-work-conserving warning in qfq Qdisc.

        Signed-off-by: Liu Jian <liujian56@huawei.com>
        Link: https://lore.kernel.org/r/20231023064729.370649-1-liujian56@huawei.com
        Signed-off-by: Paolo Abeni <pabeni@redhat.com>

    Signed-off-by: Davide Caratti <dcaratti@redhat.com>
    Signed-off-by: Patrick Talbert <ptalbert@redhat.com>

Signed-off-by: Joe Lawrence <joe.lawrence@redhat.com>
---
 net/sched/klp_cve_2023_4921.h | 16 ++++++++++++++
 net/sched/sch_atm.c           |  5 +++--
 net/sched/sch_drr.c           |  3 ++-
 net/sched/sch_dsmark.c        |  3 ++-
 net/sched/sch_ets.c           |  3 ++-
 net/sched/sch_hfsc.c          |  5 +++--
 net/sched/sch_multiq.c        |  3 ++-
 net/sched/sch_prio.c          |  3 ++-
 net/sched/sch_qfq.c           | 41 +++++++++++++++++++++++++----------
 net/sched/sch_red.c           |  3 ++-
 net/sched/sch_sfb.c           |  3 ++-
 net/sched/sch_taprio.c        |  3 ++-
 net/sched/sch_tbf.c           |  3 ++-
 13 files changed, 70 insertions(+), 24 deletions(-)
 create mode 100644 net/sched/klp_cve_2023_4921.h

diff --git a/net/sched/klp_cve_2023_4921.h b/net/sched/klp_cve_2023_4921.h
new file mode 100644
index 000000000000..07a5624a487c
--- /dev/null
+++ b/net/sched/klp_cve_2023_4921.h
@@ -0,0 +1,16 @@
+#ifndef __KLP_CVE_2023_4921__
+#define __KLP_CVE_2023_4921__
+
+static inline struct sk_buff *klp_cve_2023_4921_peek(struct Qdisc *sch)
+{
+	/*
+	 * kpatch workaround: can't modify plug_qdisc_ops structure, so
+	 * provide a peek pivot based on the underlying qdisc ops id
+	 */
+	if (strcmp(sch->ops->id, "plug") == 0)
+		return qdisc_peek_dequeued(sch);
+
+	return sch->ops->peek(sch);
+}
+
+#endif
diff --git a/net/sched/sch_atm.c b/net/sched/sch_atm.c
index 73dced0e11d7..6a894958c951 100644
--- a/net/sched/sch_atm.c
+++ b/net/sched/sch_atm.c
@@ -16,6 +16,7 @@
 #include <net/netlink.h>
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
+#include "klp_cve_2023_4921.h"
 
 /*
  * The ATM queuing discipline provides a framework for invoking classifiers
@@ -480,7 +481,7 @@ static void sch_atm_dequeue(unsigned long data)
 		 * If traffic is properly shaped, this won't generate nasty
 		 * little bursts. Otherwise, it may ... (but that's okay)
 		 */
-		while ((skb = flow->q->ops->peek(flow->q))) {
+		while ((skb = klp_cve_2023_4921_peek(flow->q))) {
 			if (!atm_may_send(flow->vcc, skb->truesize))
 				break;
 
@@ -534,7 +535,7 @@ static struct sk_buff *atm_tc_peek(struct Qdisc *sch)
 
 	pr_debug("atm_tc_peek(sch %p,[qdisc %p])\n", sch, p);
 
-	return p->link.q->ops->peek(p->link.q);
+	return klp_cve_2023_4921_peek(p->link.q);
 }
 
 static int atm_tc_init(struct Qdisc *sch, struct nlattr *opt,
diff --git a/net/sched/sch_drr.c b/net/sched/sch_drr.c
index 89b2ee29e069..7e7e26b4d18c 100644
--- a/net/sched/sch_drr.c
+++ b/net/sched/sch_drr.c
@@ -17,6 +17,7 @@
 #include <net/sch_generic.h>
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
+#include "klp_cve_2023_4921.h"
 
 struct drr_class {
 	struct Qdisc_class_common	common;
@@ -379,7 +380,7 @@ static struct sk_buff *drr_dequeue(struct Qdisc *sch)
 		goto out;
 	while (1) {
 		cl = list_first_entry(&q->active, struct drr_class, alist);
-		skb = cl->qdisc->ops->peek(cl->qdisc);
+		skb = klp_cve_2023_4921_peek(cl->qdisc);
 		if (skb == NULL) {
 			qdisc_warn_nonwc(__func__, cl->qdisc);
 			goto out;
diff --git a/net/sched/sch_dsmark.c b/net/sched/sch_dsmark.c
index 408aae32c7f6..9c137c21bdbc 100644
--- a/net/sched/sch_dsmark.c
+++ b/net/sched/sch_dsmark.c
@@ -17,6 +17,7 @@
 #include <net/dsfield.h>
 #include <net/inet_ecn.h>
 #include <asm/byteorder.h>
+#include "klp_cve_2023_4921.h"
 
 /*
  * classid	class		marking
@@ -329,7 +330,7 @@ static struct sk_buff *dsmark_peek(struct Qdisc *sch)
 
 	pr_debug("%s(sch %p,[qdisc %p])\n", __func__, sch, p);
 
-	return p->q->ops->peek(p->q);
+	return klp_cve_2023_4921_peek(p->q);
 }
 
 static int dsmark_init(struct Qdisc *sch, struct nlattr *opt,
diff --git a/net/sched/sch_ets.c b/net/sched/sch_ets.c
index b10efeaf0629..478b8e6815f4 100644
--- a/net/sched/sch_ets.c
+++ b/net/sched/sch_ets.c
@@ -35,6 +35,7 @@
 #include <net/pkt_cls.h>
 #include <net/pkt_sched.h>
 #include <net/sch_generic.h>
+#include "klp_cve_2023_4921.h"
 
 struct ets_class {
 	struct list_head alist; /* In struct ets_sched.active. */
@@ -473,7 +474,7 @@ static struct sk_buff *ets_qdisc_dequeue(struct Qdisc *sch)
 			goto out;
 
 		cl = list_first_entry(&q->active, struct ets_class, alist);
-		skb = cl->qdisc->ops->peek(cl->qdisc);
+		skb = klp_cve_2023_4921_peek(cl->qdisc);
 		if (!skb) {
 			qdisc_warn_nonwc(__func__, cl->qdisc);
 			goto out;
diff --git a/net/sched/sch_hfsc.c b/net/sched/sch_hfsc.c
index 70b0c5873d32..0be62a0b8d86 100644
--- a/net/sched/sch_hfsc.c
+++ b/net/sched/sch_hfsc.c
@@ -67,6 +67,7 @@
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
 #include <asm/div64.h>
+#include "klp_cve_2023_4921.h"
 
 /*
  * kernel internal service curve representation:
@@ -834,7 +835,7 @@ qdisc_peek_len(struct Qdisc *sch)
 	struct sk_buff *skb;
 	unsigned int len;
 
-	skb = sch->ops->peek(sch);
+	skb = klp_cve_2023_4921_peek(sch);
 	if (unlikely(skb == NULL)) {
 		qdisc_warn_nonwc("qdisc_peek_len", sch);
 		return 0;
@@ -1556,7 +1557,7 @@ hfsc_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
 		 * to invalidate the deadline.
 		 */
 		if (cl->cl_flags & HFSC_RSC)
-			cl->qdisc->ops->peek(cl->qdisc);
+			klp_cve_2023_4921_peek(cl->qdisc);
 
 	}
 
diff --git a/net/sched/sch_multiq.c b/net/sched/sch_multiq.c
index a1d875f479bd..711d05df9615 100644
--- a/net/sched/sch_multiq.c
+++ b/net/sched/sch_multiq.c
@@ -26,6 +26,7 @@
 #include <net/netlink.h>
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
+#include "klp_cve_2023_4921.h"
 
 struct multiq_sched_data {
 	u16 bands;
@@ -146,7 +147,7 @@ static struct sk_buff *multiq_peek(struct Qdisc *sch)
 		if (!netif_xmit_stopped(
 		    netdev_get_tx_queue(qdisc_dev(sch), curband))) {
 			qdisc = q->queues[curband];
-			skb = qdisc->ops->peek(qdisc);
+			skb = klp_cve_2023_4921_peek(qdisc);
 			if (skb)
 				return skb;
 		}
diff --git a/net/sched/sch_prio.c b/net/sched/sch_prio.c
index 9f85ef681ecb..0486b8caad5c 100644
--- a/net/sched/sch_prio.c
+++ b/net/sched/sch_prio.c
@@ -21,6 +21,7 @@
 #include <net/netlink.h>
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
+#include "klp_cve_2023_4921.h"
 
 struct prio_sched_data {
 	int bands;
@@ -105,7 +106,7 @@ static struct sk_buff *prio_peek(struct Qdisc *sch)
 
 	for (prio = 0; prio < q->bands; prio++) {
 		struct Qdisc *qdisc = q->queues[prio];
-		struct sk_buff *skb = qdisc->ops->peek(qdisc);
+		struct sk_buff *skb = klp_cve_2023_4921_peek(qdisc);
 		if (skb)
 			return skb;
 	}
diff --git a/net/sched/sch_qfq.c b/net/sched/sch_qfq.c
index 0f0085200db6..d0bacfca1e66 100644
--- a/net/sched/sch_qfq.c
+++ b/net/sched/sch_qfq.c
@@ -18,6 +18,7 @@
 #include <net/sch_generic.h>
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
+#include "klp_cve_2023_4921.h"
 
 
 /*  Quick Fair Queueing Plus
@@ -976,19 +977,24 @@ static void qfq_update_eligible(struct qfq_sched *q)
 }
 
 /* Dequeue head packet of the head class in the DRR queue of the aggregate. */
-static void agg_dequeue(struct qfq_aggregate *agg,
-			struct qfq_class *cl, unsigned int len)
+static struct sk_buff *agg_dequeue(struct qfq_aggregate *agg,
+				   struct qfq_class *cl, unsigned int len)
 {
-	qdisc_dequeue_peeked(cl->qdisc);
+	struct sk_buff *skb = qdisc_dequeue_peeked(cl->qdisc);
+
+	if (!skb)
+		return NULL;
 
 	cl->deficit -= (int) len;
 
 	if (cl->qdisc->q.qlen == 0) /* no more packets, remove from list */
 		list_del(&cl->alist);
-	else if (cl->deficit < qdisc_pkt_len(cl->qdisc->ops->peek(cl->qdisc))) {
+	else if (cl->deficit < qdisc_pkt_len(klp_cve_2023_4921_peek(cl->qdisc))) {
 		cl->deficit += agg->lmax;
 		list_move_tail(&cl->alist, &agg->active);
 	}
+
+	return skb;
 }
 
 static inline struct sk_buff *qfq_peek_skb(struct qfq_aggregate *agg,
@@ -998,10 +1004,16 @@ static inline struct sk_buff *qfq_peek_skb(struct qfq_aggregate *agg,
 	struct sk_buff *skb;
 
 	*cl = list_first_entry(&agg->active, struct qfq_class, alist);
-	skb = (*cl)->qdisc->ops->peek((*cl)->qdisc);
-	if (skb == NULL)
-		WARN_ONCE(1, "qfq_dequeue: non-workconserving leaf\n");
-	else
+	skb = klp_cve_2023_4921_peek((*cl)->qdisc);
+	if (skb == NULL) {
+		/*
+		 * kpatch-build workaround: keep old WARN_ONCE to avoid
+		 * create-diff-object unreconcilable difference from
+		 * unsupported .data.once section change.
+		 */
+		WARN_ONCE(!jiffies, "qfq_dequeue: non-workconserving leaf\n");
+		qdisc_warn_nonwc("qfq_dequeue", (*cl)->qdisc);
+	} else
 		*len = qdisc_pkt_len(skb);
 
 	return skb;
@@ -1134,11 +1146,18 @@ static struct sk_buff *qfq_dequeue(struct Qdisc *sch)
 	if (!skb)
 		return NULL;
 
-	qdisc_qstats_backlog_dec(sch, skb);
 	sch->q.qlen--;
+
+	skb = agg_dequeue(in_serv_agg, cl, len);
+
+	if (!skb) {
+		sch->q.qlen++;
+		return NULL;
+	}
+
+	qdisc_qstats_backlog_dec(sch, skb);
 	qdisc_bstats_update(sch, skb);
 
-	agg_dequeue(in_serv_agg, cl, len);
 	/* If lmax is lowered, through qfq_change_class, for a class
 	 * owning pending packets with larger size than the new value
 	 * of lmax, then the following condition may hold.
@@ -1247,7 +1266,7 @@ static int qfq_enqueue(struct sk_buff *skb, struct Qdisc *sch,
 	agg = cl->agg;
 	/* if the queue was not empty, then done here */
 	if (!first) {
-		if (unlikely(skb == cl->qdisc->ops->peek(cl->qdisc)) &&
+		if (unlikely(skb == klp_cve_2023_4921_peek(cl->qdisc)) &&
 		    list_first_entry(&agg->active, struct qfq_class, alist)
 		    == cl && cl->deficit < len)
 			list_move_tail(&cl->alist, &agg->active);
diff --git a/net/sched/sch_red.c b/net/sched/sch_red.c
index b04f7cdea794..7fcac73d1f21 100644
--- a/net/sched/sch_red.c
+++ b/net/sched/sch_red.c
@@ -22,6 +22,7 @@
 #include <net/pkt_cls.h>
 #include <net/inet_ecn.h>
 #include <net/red.h>
+#include "klp_cve_2023_4921.h"
 
 
 /*	Parameters, settable by user:
@@ -174,7 +175,7 @@ static struct sk_buff *red_peek(struct Qdisc *sch)
 	struct red_sched_data *q = qdisc_priv(sch);
 	struct Qdisc *child = q->qdisc;
 
-	return child->ops->peek(child);
+	return klp_cve_2023_4921_peek(child);
 }
 
 static void red_reset(struct Qdisc *sch)
diff --git a/net/sched/sch_sfb.c b/net/sched/sch_sfb.c
index 266f6c931115..0e0427024eb6 100644
--- a/net/sched/sch_sfb.c
+++ b/net/sched/sch_sfb.c
@@ -27,6 +27,7 @@
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
 #include <net/inet_ecn.h>
+#include "klp_cve_2023_4921.h"
 
 /*
  * SFB uses two B[l][n] : L x N arrays of bins (L levels, N bins per level)
@@ -450,7 +451,7 @@ static struct sk_buff *sfb_peek(struct Qdisc *sch)
 	struct sfb_sched_data *q = qdisc_priv(sch);
 	struct Qdisc *child = q->qdisc;
 
-	return child->ops->peek(child);
+	return klp_cve_2023_4921_peek(child);
 }
 
 /* No sfb_drop -- impossible since the child doesn't return the dropped skb. */
diff --git a/net/sched/sch_taprio.c b/net/sched/sch_taprio.c
index ece17aa09ff9..6797aa6dc382 100644
--- a/net/sched/sch_taprio.c
+++ b/net/sched/sch_taprio.c
@@ -26,6 +26,7 @@
 #include <net/tcp.h>
 
 #include "sch_mqprio_lib.h"
+#include "klp_cve_2023_4921.h"
 
 static LIST_HEAD(taprio_list);
 static struct static_key_false taprio_have_broken_mqprio;
@@ -722,7 +723,7 @@ static struct sk_buff *taprio_dequeue_from_txq(struct Qdisc *sch, int txq,
 	if (TXTIME_ASSIST_IS_ENABLED(q->flags))
 		goto skip_peek_checks;
 
-	skb = child->ops->peek(child);
+	skb = klp_cve_2023_4921_peek(child);
 	if (!skb)
 		return NULL;
 
diff --git a/net/sched/sch_tbf.c b/net/sched/sch_tbf.c
index 9c6a0339f4b0..440c893596a8 100644
--- a/net/sched/sch_tbf.c
+++ b/net/sched/sch_tbf.c
@@ -22,6 +22,7 @@
 #include <net/sch_generic.h>
 #include <net/pkt_cls.h>
 #include <net/pkt_sched.h>
+#include "klp_cve_2023_4921.h"
 
 
 /*	Simple Token Bucket Filter.
@@ -275,7 +276,7 @@ static struct sk_buff *tbf_dequeue(struct Qdisc *sch)
 	struct tbf_sched_data *q = qdisc_priv(sch);
 	struct sk_buff *skb;
 
-	skb = q->qdisc->ops->peek(q->qdisc);
+	skb = klp_cve_2023_4921_peek(q->qdisc);
 
 	if (skb) {
 		s64 now;
-- 
2.43.0


